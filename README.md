# RSA-Based-Cryptography
Students: 
- Lê Trí Đức - 24520009
- Phạm Nguyễn Thành Long - 24521011

Lecturer: Nguyễn Ngọc Tự

# Overview
- Scenario: Secure service company uses RSA-based algorithms for securing transactions and digital signatures. They want to ensure the robustness of their RSA implementation against potential attacks. 
- Gaps: While RSA is a widely accepted and used in public-key cryptosystem, improper implementations or usage of weak parameters can lead to vulnerabilities.
- Motivations: To ensure the integrity and confidentiality of financial transactions and to maintain the trust of clients and stakeholders. 

# Mathematical Background

## Factoring Problem in the Context of RSA

### 1. Context

In our setting, a trusted key-generation algorithm $\text{GenModulus}(1^n)$ outputs a triple $(N, p, q)$, where $p$ and $q$ are random $n$-bit primes and $N = pq$.

The RSA public key contains $N$ (and a public exponent $e$), while the prime factors $p$ and $q$ are kept secret and form part of the private key.

In practice, this modulus $N$ is embedded in:

- Server certificates used in TLS connections (e.g., for online payments or secure APIs),
- Digital-signature keys used to sign transactions, contracts, or software updates,
- Possibly hardware tokens / HSMs used by the service provider.

An external adversary $\mathcal{A}$ can freely observe $N$ (it is public by design) and may obtain many ciphertexts or signatures under this modulus.  
The most direct way for $\mathcal{A}$ to break RSA is therefore to **solve the factoring problem** for $N$: find $p, q > 1$ such that $N = pq$.

The **factoring assumption** states that, for moduli generated by $\text{GenModulus}$, no efficient (polynomial-time) adversary can factor $N$ with non-negligible probability in $n$.

### 2. Risks

If the factoring assumption fails for our generated moduli, the consequences for the system are severe:

- **Private-key recovery:**  
  Once $\mathcal{A}$ computes $p$ and $q$, it can derive $\varphi(N)$ and recover the private exponent $d$.  
  At this point the adversary has a full copy of the RSA private key.

- **Loss of confidentiality:**  
  The attacker can decrypt any ciphertext encrypted under the public key $(N, e)$.  
  This includes past recorded traffic (if stored), leading to retrospective disclosure of sensitive data such as credentials, financial information, or session keys.

- **Loss of integrity, authenticity, and non-repudiation:**  
  With the private key, the adversary can forge valid RSA signatures that are indistinguishable from signatures produced by the legitimate key owner.  
  This enables impersonation of servers, forging of transaction approvals, or signing of malicious software updates.

- **System-wide impact if keys are re-used:**  
  In many real deployments, the same RSA key pair is used across multiple services (e.g., web server, VPN, code signing).  
  Factoring a single modulus $N$ may compromise multiple independent security functions at once.

In short, **breaking the factoring assumption directly breaks the security of any RSA-based encryption or signature scheme built on that modulus**.

### 3. Security Goals

To rely on RSA securely, the system’s design must ensure that the factoring assumption is realistic for all deployed moduli:

- **Goal 1 – Hard-to-factor moduli (sufficient key sizes):**  
  Choose modulus sizes $N$ large enough that the best known classical factoring algorithms (e.g., Number Field Sieve) remain computationally infeasible in practice.  
  For current deployments, this typically means at least 2048-bit moduli, and moving to 3072-bit or higher for long-term security.

- **Goal 2 – High-quality modulus generation:**  
  Ensure $\text{GenModulus}$ uses cryptographically secure randomness to generate $p$ and $q$:  
  - primes of appropriate size,  
  - not too close to each other,  
  - not taken from small or structured sets.  
  This avoids “weak RSA keys” that might be factored using specialized attacks (e.g., shared-prime or low-entropy key attacks).

- **Goal 3 – Key isolation and minimal reuse:**  
  Avoid using the same modulus $N$ for many independent security domains (e.g., mixing TLS, code signing, and document signing with one key).  
  Even if one modulus were factored, the blast radius should be limited.

- **Goal 4 – Forward-looking protection against advances in factoring:**  
  Monitor cryptanalytic progress and adjust key sizes and lifetimes accordingly.  
  Plan for migration away from factoring-based schemes (e.g., toward post-quantum cryptography) in anticipation of quantum attacks (such as Shor’s algorithm) that would make factoring easy.

These goals collectively formalize what it means, at the system level, to “assume factoring is hard”: we must choose parameters, algorithms, and operational practices so that any realistic adversary’s success probability in factoring $N$ (as produced by $\text{GenModulus}$) remains negligible.



# Implementation and Testing
- Python 3.x

Install: https://www.python.org/downloads/
- Sagemath

See the installation guide here: https://doc.sagemath.org/html/en/installation/index.html. For the sake of convenience, it should be installed using conda-forge.

After installing, activate it with the following command:
```
duccorp@DESKTOP-RH0V9GH:~/RSA-Based-Cryptography$ source ~/miniforge3/bin/activate
(base) duccorp@DESKTOP-RH0V9GH:~/RSA-Based-Cryptography$ conda activate sage
(sage) duccorp@DESKTOP-RH0V9GH:~/RSA-Based-Cryptography$ sage
┌────────────────────────────────────────────────────────────────────┐
│ SageMath version 10.6, Release Date: 2025-03-31                    │
│ Using Python 3.11.13. Type "help()" for help.                      │
└────────────────────────────────────────────────────────────────────┘
sage:
```

You can check your SageMath version by 
```
(sage) duccorp@DESKTOP-RH0V9GH:~/RSA-Based-Cryptography$ sage --version
SageMath version 10.6, Release Date: 2025-03-31
```
In Visual Studio Code, press `Ctrl+Shift+P` and choose the correct Python interpreter before coding. 

<img width="746" height="89" alt="{034810DA-A092-4093-81BE-1FA88BCB7E2F}" src="https://github.com/user-attachments/assets/c65b8d6f-22d3-4503-88b9-9daa00dbe653" />

Import it with 
```python
from sage.all import * 
```
- Pycryptodome

Docs and installation guide of the library: https://pycryptodome.readthedocs.io/en/latest/src/introduction.html. PyCryptodome provides many cryptographic functions for working with RSA


# References
- [Twenty Years of Attacks on the RSA Cryptosystem, Dan Boneh](https://crypto.stanford.edu/~dabo/papers/RSA-survey.pdf)
- [Introduction to Modern Cryptography, Second Edition](https://eclass.uniwa.gr/modules/document/file.php/CSCYB105/Reading%20Material/%5BJonathan_Katz%2C_Yehuda_Lindell%5D_Introduction_to_Mo%282nd%29.pdf)
- [Chosen Ciphertext Attacks Against Protocols Based on the RSA Encryption Standard PKCS #1](https://archiv.infsec.ethz.ch/education/fs08/secsem/bleichenbacher98.pdf)
- [Modulus Fault Attacks Against RSA-CRT Signatures](https://eprint.iacr.org/2011/388.pdf)
- [New Partial Key Exposure Attacks on RSA](https://www.iacr.org/archive/crypto2003/27290027/27290027.pdf)
- [Small Public Exponent Brings More: Improved Partial Key Exposure Attacks against RSA](https://eprint.iacr.org/2024/1329.pdf)
- [Cache-Timing Attacks on RSA Key Generation](https://d-nb.info/1205895671/34)
- [Timing Attacks on Software Implementation of RSA](https://ir.library.oregonstate.edu/downloads/fn106z04s)
