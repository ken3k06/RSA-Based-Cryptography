from sage.all import *
from Crypto.Util.number import *
n = 868388982954131201479963675116137612306992896931272617790513066556054418385207570465450595178413774521539493802938525765839291743456344768808428636816274400852392320860469533635241549121846846199955510532198098119167528152693459663605037848666870525701692667502850484359781291856644176292197138239603813116840128440306439065322574973363097099549539442315147497941432804041389454127274300788599416072900874297262003829764501263681911221994313807470328171814767681088234884400764167084367618084182089811487512983306062393708062187780486140875125690276782346088928945047889289713307769452632645497363290366369957934147829202620228493827193161345988126450320024565706272154093286593649360213197021295549516042865867014967897628114486174184112945692325990601017009967163490031912929822607208773248838840621383601867990479185600880801724129847611545443200313393393331742474849699051808518315424346276583324110013044159114033158529839416912817446073242317289770726833743740150678123571942666688902937522148720462779922609053693463313194254069095096898942524026182770927590799764591872649173307854976286442930483777056989238423015281874011874176751039270361335481284717486194121913363398514721455342093446709010770978184665922685829007633417
e = 20
c = 640637430810406857500566702096274083827969484683203431057884917289334852774628366544173898461793872749381218755789561147579616430654545910443392999745646991166871881921220464939864253713908416530390190158949384932577913862830219713857369609459762011889417419756793122426703825117513400191620385907288504916090847305768659601562703145161353515226108384753106940659543471151834612884216177615674237258524708660356029782277496502661375640482568436495365098768844463148890142800375234779194361829383863910733638511522447466825092214583332860815273048698909839939639414519049464503518148811430663951050780377349263954109578307275120668187576579606920834997300457959369210342979008781474779797263684804038193343559153360000591890914138162679452520178353221126345668053628984789866309647708241703704572876397093327331829759682103901466789622570329436397304004981624979326705982863341122172795333419091029054076901225961700895404005870959370534342030325042659771283312708045031896875418423823654636664200180485341848613950104499288108479732463452304383581012867506699521685887270123864182790207674665585641962611326611636762153910224157810233669579162854801

def flatter(M):
    import re
    from subprocess import check_output
    # compile https://github.com/keeganryan/flatter and put it in $PATH
    z = "[[" + "]\n[".join(" ".join(map(str, row)) for row in M) + "]]"
    ret = check_output(["flatter"], input=z.encode())
    return matrix(M.nrows(), M.ncols(), list(map(int, re.findall(b"-?\\d+", ret))))

def small_roots(self, X=None, beta=1.0, epsilon=None, **kwds):
    from sage.misc.verbose import verbose
    from sage.matrix.constructor import Matrix
    from sage.rings.real_mpfr import RR
 
    N = self.parent().characteristic()
 
    if not self.is_monic():
        raise ArithmeticError("Polynomial must be monic.")
 
    beta = RR(beta)
    if beta <= 0.0 or beta > 1.0:
        raise ValueError("0.0 < beta <= 1.0 not satisfied.")
 
    f = self.change_ring(ZZ)
 
    P, (x,) = f.parent().objgens()
 
    delta = f.degree()
 
    if epsilon is None:
        epsilon = beta / 8
    verbose("epsilon = %f" % epsilon, level=2)
 
    m = max(beta**2 / (delta * epsilon), 7 * beta / delta).ceil()
    verbose("m = %d" % m, level=2)
 
    t = int((delta * m * (1 / beta - 1)).floor())
    verbose("t = %d" % t, level=2)
 
    if X is None:
        X = (0.5 * N ** (beta**2 / delta - epsilon)).ceil()
    verbose("X = %s" % X, level=2)
 
    # we could do this much faster, but this is a cheap step
    # compared to LLL
    g = [x**j * N ** (m - i) * f**i for i in range(m) for j in range(delta)]
    g.extend([x**i * f**m for i in range(t)])  # h
 
    B = Matrix(ZZ, len(g), delta * m + max(delta, t))
    for i in range(B.nrows()):
        for j in range(g[i].degree() + 1):
            B[i, j] = g[i][j] * X**j
 
    B = flatter(B)
 
    f = sum([ZZ(B[0, i] // X**i) * x**i for i in range(B.ncols())])
    R = f.roots()
 
    ZmodN = self.base_ring()
    roots = set([ZmodN(r) for r, m in R if abs(r) <= X])
    Nbeta = N**beta
    return [root for root in roots if N.gcd(ZZ(self(root))) >= Nbeta]
x = polygen(Zmod(n))
f = x**20 - c
rs = small_roots(f, X=2**204, beta=1/20)
print(rs)
for r in rs:
  flag = long_to_bytes(ZZ(r))
  print(flag)
